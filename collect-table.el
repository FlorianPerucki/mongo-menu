;;; collect.el --- Read quickly from multiple databases -*- lexical-binding: t -*-

;; Copyright (C) 2018 Florian Perucki

;; Author: Florian Perucki <florian@perucki.fr>
;; URL: https://github.com/florianperucki/collect
;; Version: 0.0.1
;; Package-Requires: ((emacs "24.1") (ivy "0.10.0") (hydra 0.14.0))
;; Keywords: database mongodb sql

;; This file is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this file. If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This package adds the `tabulated-list-mode' support to `collect'.
;; To use tabulated-list-mode configure the following variable from collect.el:
;;
;; (setq collect-selector 'table)
;;
;; `ivy' is used by default.

;;; Code:

(define-derived-mode collect-table-mode tabulated-list-mode "collect-table"
  "Collect-table mode")

(defvar collect-table-mode-map nil "Keymap generated by `collect--table-display'")

(defun collect--table-display (database collection entries actions)
  "Display results using tabulated-list-mode"
  (let* ((buffer (get-buffer-create
                  (format "*collect-table %s %s*" database collection)))
         (custom-actions (collect--get-actions database collection))
         (actions (append (or actions (list)) custom-actions)))
    ;; redefine keymap with current action bindings
    (setq collect-table-mode-map
      (let ((map (make-keymap)))
        (mapc (lambda (action)
                (define-key map (kbd (car action)) `,(cadr action)))
              actions)
        map))

    (switch-to-buffer buffer)
    (toggle-read-only -1)
    (erase-buffer)

    (setq tabulated-list-format (collect--table-get-columns database collection))

    (setq tabulated-list-entries entries)

    (collect-table-mode)

    (setq tabulated-list-use-header-line
          (not (collect--get-collection-property :no-header database collection)))

    (when tabulated-list-use-header-line
      (tabulated-list-init-header))))

(defun collect--table-get-columns (&optional database collection)
  (if collection
      ;; we've got a collection, return custom columns
      (let ((columns (collect--get-collection-property :columns database collection)))
        (vconcat
         (mapcar (lambda (column)
                   (let ((name (collect--get-column-name database collection column))
                         (width (collect--get-column-width database collection column)))
                     `(,name ,width nil)))
                 columns)))
    ;; no collection but do we have a database?
    (if database
        ;; return collections column template
        [("Collection" 50 t)]
      ;; return databases column template
      [("Database" 50 t)])
    ))

(defun collect--table-databases (entries)
  "Display database list.
ENTRIES: string list"
  (collect--display :entries (mapcar 'collect--table-format-entry-database entries)
                    :actions (list
                              '("RET" collect--table-show-collections-defined "Show collections")
                              '("O" collect--table-show-collections "Show all collections"))))

(defun collect--table-collections (database entries)
  "Display collections list for a given database.
database: string
entries: collections plist"
  (collect--display :database database
                    :entries (mapcar (apply-partially 'collect--table-format-entry-collection database) entries)))

(defun collect--table-get-current-entry (&optional entry)
  (let* ((entry (tabulated-list-get-id))
         (database (get-text-property 0 :database entry))
         ;; target collection for action, defaults to current
         (collection (get-text-property 0 :collection entry))
         ;; document unique id
         (document-id (get-text-property 0 :document-id entry)))
    (list
     :database database
     :collection collection
     :document-id document-id)))

(defun collect--table-action-show-documents (test)
  "Action to execute on a collection row: query and display a list of documents"
  (let* ((row (tabulated-list-get-id))
         (database (get-text-property 0 :database row))
         (collection (get-text-property 0 :collection row)))
    (collect--show-documents database collection)))

(defun collect--table-action-show-document ()
  "Action to execute on any row: show a single document"
  (interactive)
  (let* ((document-id (tabulated-list-get-id))
         (database (get-text-property 0 :database document-id))
         (collection (get-text-property 0 :collection document-id)))
    (collect--show-document database collection document-id)))

(defun collect--table-action-copy-id ()
  (interactive)
  "Action to execute on any row: add the row ID to the kill ring"
  (let ((document-id (tabulated-list-get-id)))
    (progn
      (message document-id)
      (kill-new document-id))))

(defun collect--table-format-entry-database (entry)
  "TODO"
  (let* ((name (car entry))
         (host (collect--get-property :host entry)))
    (list (propertize name :database name) [name host])))

(defun collect--table-format-entry-collection (database entry)
  "TODO"
  (list (propertize entry :database database :collection entry) [entry]))

(iter-defun collect--table-format-document-fields (database collection values)
  "Generate a formatted string for each field values of a single row.
database: string
collection: string
values: list of values (string, integer, etc.)"
  (let* ((collect--tmp-index 0)
         (columns (collect--get-collection-columns database collection))
         (len (length values)))
    (when (not (equal len (length columns)))
      (error "Column templates and values mismatch"))
    (while (< collect--tmp-index len)
      (let* ((value (elt values collect--tmp-index))
             (column (elt columns collect--tmp-index))
             (value (collect--get-column-value database collection column value)))
        (iter-yield value))
      (setq collect--tmp-index (1+ collect--tmp-index)))))

(defun collect--table-format-entry-document (database collection entry)
  "Return a string for a single document row.

The returned string has the following properties:
database: string name of the database
collection: string name of the collection
id: unique row identifier"
  (let ((values (list)))
    (iter-do (value (collect--table-format-document-fields database
                                                         collection
                                                         (cdr entry)))
      (setq values (append values (list value))))
    (let* ((id (car entry))
           (output (vconcat values)))
      (list
       (propertize id
                   :database database
                   :collection collection
                   :document-id id)
       output))))

(provide 'collect-table)
;;; collect-table.el ends here
